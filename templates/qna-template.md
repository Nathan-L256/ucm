# 소프트웨어 설계 Q&A 템플릿

이 템플릿은 qna.js의 인터뷰어가 설계 결정을 수집할 때 따르는 가이드다.
핵심 원칙: **무엇을 만드는지 먼저, 어떻게 만드는지는 나중에.**

---

## 그린필드 vs 브라운필드

`--project` 옵션 유무로 판단한다.

### 그린필드 (--project 없음)

프로젝트 코드가 없다. 아이디어 단계부터 시작한다.

**질문 순서:**
1. 제품 정의 → 2. 핵심 기능 → 3. 기술 스택 → 4. 설계 결정

### 브라운필드 (--project 있음)

프로젝트 코드가 있다. 코드를 스캔하여 기존 스택과 구조를 파악한 뒤 질문한다.

**질문 순서:**
1. 작업 목표 → 2. 변경 범위 → 3. 설계 결정

기술 스택은 코드에서 읽으면 되므로 물어보지 않는다.
기존 구조를 변경해야 할 때만 기술 선택 질문을 한다.

---

## 영역 1: 제품 정의 (그린필드만)

가장 먼저 확정해야 할 것. 기술 선택보다 선행한다.
**아래 순서를 반드시 지킨다. 순서를 바꾸거나 합치지 않는다.**

1. **프로젝트 유형**: 웹 앱 / API 서버 / CLI 도구 / 라이브러리 / 모바일 앱 / 풀스택
   - 유형에 따라 이후 질문 범위가 달라진다
2. **구체적 목적**: "이 도구는 구체적으로 어떤 문제를 해결하나요?"
   - 선택지는 참고용 예시다. 사용자는 번호 대신 자유 텍스트 입력이 가능하다
   - "누구를 위해 어떤 문제를 해결하는가"가 핵심
3. **사용자는 누구인가**: 개발자 / 내부 팀 / 일반 사용자 / API 소비자
   - 사용자 유형이 인터페이스 설계, 인증 방식, 문서화 수준을 결정한다
4. **규모와 수명**: 프로토타입·해커톤 / 소규모 프로덕션 / 중대형 장기 운영
   - 규모가 작으면 기술 스택 질문을 대폭 줄인다

## 영역 2: 핵심 기능 (그린필드만)

제품 정의가 끝나면 구체적 기능을 파악한다.
**이 영역에서 최소 2개 질문을 해야 한다.**

- **핵심 기능 나열**: 이 제품이 반드시 해야 하는 것 3-5가지
  - 선택지는 기능 조합의 예시로 제공한다
  - 사용자가 자유 입력으로 자신만의 기능 목록을 작성할 수 있다
  - 너무 추상적이면 구체적으로 쪼개달라고 한다
- **기능 구체화**: 앞에서 정의한 기능 중 핵심 기능의 동작 방식을 묻는다
  - 예: "프롬프트를 여러 AI에게 보낸다" → "어떤 AI들을 지원할 것인가?"
  - 사용자 답변에서 나온 기능을 참조하여 후속 질문을 만든다
- **비기능 요구사항**: 성능 / 보안 / 접근성 / 오프라인 지원 / 다국어 등
  - 해당하는 것만 선택, 대부분은 "해당 없음"
  - 프로토타입이면 생략

## 영역 3: 작업 목표 (브라운필드만)

기존 프로젝트에서 무엇을 하려는지 파악한다. **최대 2개 질문으로 끝낸다.**

- **Q1 — 작업 대상**: 코드 스캔 결과에서 발견한 모듈/파일 이름을 선택지로 나열
  - 선택지 예: "auth.ts (인증 모듈)", "api/routes.ts (라우팅)", "utils/cache.ts (캐시)"
  - 추상적 카테고리("기능 추가", "리팩토링") 대신 실제 파일/모듈 이름을 쓴다
- **Q2 — 작업 유형**: 선택된 모듈에 대해 구체적으로 무엇을 할 건지
  - 해당 모듈의 실제 함수/패턴을 참조한 선택지를 만든다

## 영역 3-1: 변경 범위 (브라운필드만)

작업 대상이 확정되면 범위를 구체화한다.

- **변경 지점**: 해당 모듈의 어떤 함수/로직을 수정하는가
  - 코드를 읽고 실제 함수명, 클래스명을 선택지에 포함한다
- **변경 범위**: 단일 파일 수정 / 모듈 내부 변경 / 모듈 간 인터페이스 변경 / 전체 구조 변경
  - 범위가 클수록 이후 설계 질문이 많아진다
- **제약사항**: 호환성 유지 필요 / 다운타임 불가 / 특정 기술 사용 필수 등

## 영역 4: 기술 스택 (그린필드만)

제품과 기능이 정의된 후에 기술을 선택한다.
**반드시 최소 1개 질문(언어/런타임)은 해야 한다. 추론으로 건너뛰지 않는다.**

- **언어**: TypeScript / Python / Go / Rust / Java·Kotlin / 기타
  - 이전에 정의한 기능과 사용자 유형에 맞는 선택지를 제시
- **런타임·프레임워크**: 언어와 프로젝트 유형에 따라 후보를 좁혀서 제시
  - 웹 앱: Next.js / Remix / SvelteKit / Nuxt 등
  - API 서버: Express / Fastify / Hono / FastAPI / Gin 등
  - CLI: Commander / oclif / Click / Cobra 등
  - 프로토타입 규모면 프레임워크 질문 하나로 충분
- **데이터 저장소**: 기능 요구사항에서 데이터 저장이 필요하면 질문
  - 필요 없으면 건너뛴다

## 영역 5: 설계 결정

제품·기능·기술이 정해진 후, 구현에 필요한 설계를 결정한다.
**앞선 답변에 따라 관련 있는 것만 질문한다.**

### 아키텍처

- 디렉토리 구조 / 모듈 경계
- 모놀리스 vs 마이크로서비스 (규모가 클 때만)
- 비동기 처리 패턴 (필요할 때만)

### API 설계 (API가 있는 프로젝트만)

- API 스타일: REST / GraphQL / tRPC / gRPC
- 요청/응답 검증 방식
- 에러 응답 형식

### 인증 (사용자 인증이 필요한 프로젝트만)

- 인증 방식: 세션 / JWT / OAuth / API 키
- 인증 제공자: 직접 구현 / 외부 서비스
- 인가 모델: RBAC / ABAC / 소유자 확인

### 테스트 (프로토타입이 아닌 경우만)

- 테스트 범위 전략
- 테스트 프레임워크

### 배포 (프로토타입이 아닌 경우만)

- 배포 대상과 방식
- CI/CD 플랫폼
- 환경 구분

### 코드 품질 (팀 프로젝트이거나 장기 운영인 경우만)

- 린터/포매터
- 브랜치 전략
- 커밋 컨벤션

---

## 질문 생성 규칙

### 순서

1. 그린필드: 제품 정의 → 핵심 기능 → 기술 스택 → 설계 결정
2. 브라운필드: 작업 목표 → 변경 범위 → 설계 결정
3. **기술 스택을 제품/기능보다 먼저 묻지 않는다**
4. **앞선 결정으로 불필요해진 영역은 건너뛴다**

### 스킵 규칙

- 프로토타입/해커톤 → 테스트, 배포, 코드 품질 영역 대폭 축소 또는 생략
- CLI 도구 → 인증, 클라이언트 상태, E2E 생략
- 라이브러리 → 인증, API 설계, 관측성 생략. 배포는 패키지 퍼블리시로 전환
- 브라운필드 → 기존 코드에서 이미 결정된 사항은 스킵
- 1인 프로젝트 → 코드 리뷰, 브랜치 전략 생략

### 선택지 작성

- reason에 **구체적 트레이드오프**를 포함한다 (장점만 나열 금지)
- 앞선 결정과 모순되는 선택지는 제외한다
- "해당 없음" / "나중에 결정"도 유효한 선택지다
- 브라운필드에서 기존 패턴과 다른 선택지를 제시할 때는 변경 이유를 reason에 명시한다
- **"직접 입력하겠습니다" 같은 메타 선택지를 만들지 않는다.** 사용자는 항상 번호 대신 자유 텍스트를 입력할 수 있다

### 깊이 조절

- 각 영역 핵심 1-3개 질문이면 충분하다
- 규모가 작을수록 질문을 줄인다
- 사용자가 "나중에 결정"을 많이 선택하면 남은 질문도 줄인다
